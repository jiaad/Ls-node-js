#!/usr/bin/env node
const fs = require('fs');
const colors = require('colors');
const util = require('util');
const process = require('process');
const { throws } = require('assert');    
const Utils = require('./Utils')
const ArgvHandler = require('./ArgvHandler');
const childProcess = require('child_process');
// const { argv, exec } = require('process');
// const childProcess = 
// * PROMISIFY callbacks
const readFile = util.promisify(fs.readFile);
const openFile = util.promisify(fs.open)
const fstat = util.promisify(fs.fstat)
const Stats = util.promisify(fs.stat)
const fsAccess = util.promisify(fs.access)
const lstat = util.promisify(fs.lstat)
const exec = util.promisify(childProcess.exec)
class Ls {

  constructor() {
    this.utils = new Utils()
    this.argvHandler = new ArgvHandler()
    // let p = await this.argvHandler.changeDir()
    // console.log('lmao', p)
  }



async  getFileFD (fd, dirent){
    try {
        fd = dirent.name
        return await openFile(fd)
    } catch (e) {
      // console.log('ERROR IN CATCH BLOCK FT_LS : ', e)
      throw 'ERROR IN CATCH BLOCK: NO FILE OR DIRECTORY'
    }

}

async  getAllInfoForls(directoryName = '.') {
  let res = [];
  let fileDescriptor;
  let directory = directoryName !== '.' ?  `./${directoryName}` : '.'
  let dir;
  try {
    dir = await fs.promises.opendir(directory) // OPEN THE DIR  
  } catch (e) {
    throw `Command: ${directory} doesn't exists`
  }
    // if directory does change, it will enter into the mentionned directory
    // Got rid of try catch block, not necessary
    if(directory !== '.'){
      process.chdir(directory);
    }
  for await (const dirent of dir) {
    
    // determine if it's a file of directory
    const type = dirent.isFile() ? true : false
    const name =  dirent.name
    try {
      const fd = await this.getFileFD(fileDescriptor, dirent)
    } catch (error) {
      process.stdout.write(error + "\n")
    }
    const stats = await Stats(name) // to Get stats about FILE or DIR
    const toPush = this.utils.pushStatsToArray(stats, type, name) // CREATE OBJECT FOR ARRAY
    res.push(toPush) // PUSH TO ARRAY
  } // FOR OF FINISH

  if (directory !== '.') 
    process.chdir('../')

  return res
}

async noFlagLs(stockRes){
  let sorted  = stockRes.sort((a, b) => a.name.localeCompare(b.name))
  sorted.forEach(async element => {
    element = await this.utils.colorizeOutput(element)
    process.stdout.write(element + '      ')
  });
}

async loopShowFilesAndDirectories(stockResult){
  let i = 0
  for (i = 0; i < stockResult.length; i++) {
    const element = stockResult[i];
    const elSize = String(element.size)
    let name = element.name
    name = await this.utils.colorizeOutput(element)
    process.stdout.write(name + '           ')
  }
  // console.log(stockResult)
  // if(i === stockResult.length - 1)
    process.stdout.write('\n')
}

  async lsOneArgFileorDir(args){
    try {
      // let name = args//.slice(2)
      let fileOrDir = await lstat(args)
      let res = await fileOrDir.isDirectory()
      if(res === true){
        let stockResult = await this.getAllInfoForls(args)
        this.loopShowFilesAndDirectories(stockResult)
      }else{
        process.stdout.write(args + "\n")
      }
    } catch (e) {
      throw `ls: ${e.path} no such file or directory XD\n`
    }
  }
  async lsAllFilesAndDirectories(){
    let {files, dirs} = await this.argvHandler.argvDirectories() // get an array of object {files, dirs} // destructuring
    // PRINT FILES BEFORE DIRS
    files.upcaseFiles.map(a => process.stdout.write(a + "         "))
    files.downcaseFiles.map(a => process.stdout.write(a + " "))
    files.upcaseFiles.length >= 1 || files.downcaseFiles.length >= 1 
    ? process.stdout.write("\n\n"): null // Print them

    let len = dirs.length
    for (let i = 0; i < len; i++) {
      let stockResult;
      const dirName = dirs[i];
      try {
      stockResult = await this.getAllInfoForls(dirName)
      } catch (e) {
        process.stdout.write(e + '\n')
      }
        process.stdout.write(dirName + ':' + '\n')
        await this.loopShowFilesAndDirectories(stockResult)
      if(!(i === (len - 1) ))
        process.stdout.write('\n')
    }
  }
//////////// MAKE A GLOBAL TRY
  async lsOutput(){
    let args = process.argv.slice(2)
    try{
      if(args.length <= 0){ /// if no argument, then print current directory
          let stockRes = await this.getAllInfoForls()
          await this.noFlagLs(stockRes)
          process.stdout.write('\n')
      }
      else if(args.length === 1){
        try{
          let directoryName = args[0]
          await this.lsOneArgFileorDir(directoryName)
        }catch(err){
          // console.log(err)
          process.stdout.write(err)
        }
      }
      else{
        await this.argvHandler.showDirectoryErrors() // show errors
        await this.lsAllFilesAndDirectories()// this does show everything
      } // else
    }catch(error){
      process.stdout.write("THE ERROR NOFLAGWITH DIRECTORIES: " + error + "\n")
    }

  }

  async  lsPrettier() {
    let name = 'name'  
    let type = 'type' 
    let size = 'size'  
    let created = 'created'
    let stockRes;

    let args = process.argv.slice(2)
      try {
        await this.lsOutput()
      } catch (e) {
        process.stdout.write("LAST E : " + e)
      }

  }

}

let lsExec = new Ls()
lsExec.lsPrettier()
