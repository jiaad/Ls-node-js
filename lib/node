#!/usr/bin/env node
const fs = require('fs');
const colors = require('colors');
const util = require('util');
const process = require('process');
const { throws } = require('assert');    
const Utils = require('./Utils')
const ArgvHandler = require('./ArgvHandler');
const { argv } = require('process');
// * PROMISIFY callbacks
const readFile = util.promisify(fs.readFile);
const openFile = util.promisify(fs.open)
const fstat = util.promisify(fs.fstat)
const Stats = util.promisify(fs.stat)
const fsAccess = util.promisify(fs.access)
const lstat = util.promisify(fs.lstat)


class Ls {

  constructor() {
    this.utils = new Utils()
    this.argvHandler = new ArgvHandler()
  }



async  getFileFD (name, isFile, fd, dirent){
    try {
        fd = dirent.name
        return await openFile(fd)
    } catch (e) {
      // console.log('ERROR IN CATCH BLOCK FT_LS : ', e)
      throw 'ERROR IN CATCH BLOCK: NO FILE OR DIRECTORY'
    }

}

async  getAllInfoForls(directoryName = '.') {
  let res = [];
  let fileDescriptor;
  // let directoryName = this.argvHandler.argvDirectory() !== undefined ? this.argvDirectory() : '.'
  let directory = directoryName !== '.' ?  `./${directoryName}` : '.'
  // await this.quiIfDirectoryDoesntExist(directoryName)
  let dir;
  try {
    dir = await fs.promises.opendir(directory) // OPEN THE DIR  
  } catch (e) {
    throw `Command: ${directory} doesn't exists`


  }
  try {
    if(directory !== '.'){
      process.chdir(directory);
    }
  } catch (e) {
    console.error(`chdir: ${e}`);
  }


  for await (const dirent of dir) {
    
    // determine if it's a file of directory
    const type = dirent.isFile() ? true : false
    const name =  dirent.name
    try {
      const fd = await this.getFileFD(name, type, fileDescriptor, dirent)
    } catch (error) {
      // console.log(error)
      process.stdout.write(error + "\n")
    }
    const stats = await Stats(name) // to Get stats about FILE or DIR
    const toPush = this.utils.pushStatsToArray(stats, type, name) // CREATE OBJECT FOR ARRAY
    res.push(toPush) // PUSH TO ARRAY
  } // FOR OF FINISH

  if (directory !== '.') {
    process.chdir('../')
  }
  // console.log(this.res)
  return res
}

async noFlagLs(stockRes){
  // let args = this.argvHandler.argvDirectories()
  let arr = new Array
  stockRes.forEach((item) => arr.push(item.name))
  arr.sort().map((item) => process.stdout.write(item + '  '))
  // process.stdout.write('-------------------------')
  process.stdout.write(`\n`);
}

async loopShowFilesAndDirectories(stockResult){
  let i = 0
  for (i = 0; i < stockResult.length; i++) {
    const element = stockResult[i];
    const elSize = String(element.size)
    let name = element.name
    if(element.type === 'directory')
      name = element.name.blue
    if(element.type === 'file')
      name = element.name.white
    if(element.mode === 33261)
      name = element.name.red
    process.stdout.write(name + '           ')
  }
  // console.log(stockResult)
  // if(i === stockResult.length - 1)
    process.stdout.write('\n')
}

  async lsOneArgFileorDir(args){
    try {
      let name = args//.slice(2)
      let fileOrDir = await lstat(args)
      let res = await fileOrDir.isDirectory()
      if(res === true){
        let stockResult = await this.getAllInfoForls(args)
        this.loopShowFilesAndDirectories(stockResult)
      }else{
        process.stdout.write(args + "\n")
      }
    } catch (e) {
      throw `ls: ${e.path}no such file or directory XD`
    }
  }
//////////// MAKE A GLOBAL TRY
  async noFlagButWithDirectories(){
    let args = process.argv.slice(2)
    try{
      if(args.length <= 0){ /// if no argument, then print current directory
          let stockRes = await this.getAllInfoForls()
          await this.noFlagLs(stockRes)
      }
      else if(args.length === 1){
        try{
          let directoryName = args[0]
          await this.lsOneArgFileorDir(directoryName)
        }catch(err){
          // console.log(err)
          process.stdout.write(err)
        }
      }
      else{
          await this.argvHandler.showDirectoryErrors() // show errors

          let {files, dirs} = await this.argvHandler.argvDirectories() // get an array of object {files, dirs} // destructuring
          let len = dirs.length

          files.upcaseFiles.map(a => process.stdout.write(a + "         "))
          files.downcaseFiles.map(a => process.stdout.write(a + " "))
          files.upcaseFiles.length >= 1 || files.downcaseFiles.length >= 1 ? 
            process.stdout.write("\n\n"): null // Print them
          for (let i = 0; i < len; i++) {
            let stockResult;
            const directoryName = dirs[i];
            let exists = await this.utils.doesFileOrDirExists(directoryName)
            try {
              stockResult = await this.getAllInfoForls(directoryName)
            } catch (e) {
              // console.log(e)
              process.stdout.write(e)
            }
            if(exists == true){
              // process.stdout.write('\n\n')
              process.stdout.write(directoryName + ":" + "\n")
              this.loopShowFilesAndDirectories(stockResult)
            }
            // console.log("IIII:", len, i, i == len - 1)
            if(!(i === len - 1))
              process.stdout.write("\n")

          }
    }
    }catch(error){
      process.stdout.write("THE ERROR NOFLAGWITH DIRECTORIES: " + error + "\n")
    }

  }

  async  lsPrettier() {
    let name = 'name'  
    let type = 'type' 
    let size = 'size'  
    let created = 'created'
    let stockRes;

    let args = process.argv.slice(2)
      try {
        await this.noFlagButWithDirectories()
      } catch (e) {
        process.stdout.write("LAST E : " + e)
      }

  }

}

let lsExec = new Ls()
lsExec.lsPrettier()
